{
  "@context": {
    "actual": {
      "@id": "http://a.ml/vocabularies/validation#actual"
    },
    "apiContract": "http://a.ml/vocabularies/apiContract#",
    "argument": {
      "@id": "http://a.ml/vocabularies/validation#argument"
    },
    "column": {
      "@id": "http://a.ml/vocabularies/lexical#column"
    },
    "component": {
      "@id": "http://a.ml/vocabularies/validation#component"
    },
    "condition": {
      "@id": "http://a.ml/vocabularies/validation#condition"
    },
    "conforms": {
      "@id": "http://www.w3.org/ns/shacl#conforms"
    },
    "core": "http://a.ml/vocabularies/core#",
    "data": "http://a.ml/vocabularies/data#",
    "doc": "http://a.ml/vocabularies/document#",
    "end": {
      "@id": "http://a.ml/vocabularies/lexical#end"
    },
    "expected": {
      "@id": "http://a.ml/vocabularies/validation#expected"
    },
    "focusNode": {
      "@id": "http://www.w3.org/ns/shacl#focusNode"
    },
    "lexical": "http://a.ml/vocabularies/lexical#",
    "line": {
      "@id": "http://a.ml/vocabularies/lexical#line"
    },
    "location": {
      "@id": "http://a.ml/vocabularies/validation#location"
    },
    "negated": {
      "@id": "http://a.ml/vocabularies/validation#negated"
    },
    "range": {
      "@id": "http://a.ml/vocabularies/lexical#range"
    },
    "rdf": "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
    "rdfs": "http://www.w3.org/2000/01/rdf-schema",
    "result": {
      "@id": "http://www.w3.org/ns/shacl#result"
    },
    "resultMessage": {
      "@id": "http://www.w3.org/ns/shacl#resultMessage"
    },
    "resultPath": {
      "@id": "http://www.w3.org/ns/shacl#resultPath"
    },
    "resultSeverity": {
      "@id": "http://www.w3.org/ns/shacl#resultSeverity"
    },
    "security": "http://a.ml/vocabularies/security#",
    "shacl": "http://www.w3.org/ns/shacl#",
    "shapes": "http://a.ml/vocabularies/shapes#",
    "sourceShapeName": {
      "@id": "http://a.ml/vocabularies/validation#sourceShapeName"
    },
    "sourcemaps": "http://a.ml/vocabularies/document-source-maps#",
    "start": {
      "@id": "http://a.ml/vocabularies/lexical#start"
    },
    "subResult": {
      "@id": "http://a.ml/vocabularies/validation#subResult"
    },
    "trace": {
      "@id": "http://a.ml/vocabularies/validation#trace"
    },
    "traceValue": {
      "@id": "http://www.w3.org/ns/shacl#traceValue"
    },
    "uri": {
      "@id": "http://a.ml/vocabularies/lexical#uri"
    },
    "validation": "http://a.ml/vocabularies/validation#",
    "xsd": "http://www.w3.org/2001/XMLSchema#"
  },
  "@type": "shacl:ValidationReport",
  "conforms": false,
  "result": [
    {
      "@type": [
        "shacl:ValidationResult"
      ],
      "focusNode": {
        "@id": "file://./test/data/production/security/negative1.oas#/web-api"
      },
      "resultMessage": "Description\n\nThe security field of your API contract does not list any security schemes to be applied. Instead, it just contains\nan empty array.\n\nThe top-level security field of the OpenAPI contract contains an array of the security schemes applied to the whole\nAPI. The list of values describes alternative security schemes that can be used. There is a logical OR between the\nsecurity requirements. Individual operations can override the top-level security in the operation-level security\nfields if needed.\n\nPossible exploit scenario\n\nEven though you can apply security schemes directly to individual operations, it is strongly recommended that you\ndefine your default security schemes on the API level. The operation-level security is meant to be used as an\nexception-handling mechanism only, not as a best practice.\n\nRelying on defining security only on each operation individually is an error-prone approach. It is very easy to\nforget to set security when you add a new method to the API. If there is no global default security defined, the\noperation is left wide open for an attacker to invoke without any authentication required.\n",
      "resultSeverity": {
        "@id": "http://www.w3.org/ns/shacl#Violation"
      },
      "sourceShapeName": "security-fields-empty",
      "trace": [
        {
          "@type": [
            "validation:TraceMessage"
          ],
          "component": "minCount",
          "resultPath": "security.security",
          "traceValue": {
            "actual": 0,
            "condition": ">=",
            "expected": 1,
            "negated": false
          }
        },
        {
          "@type": [
            "validation:TraceMessage"
          ],
          "component": "nested",
          "resultPath": "apiContract.endpoint / apiContract.supportedOperation",
          "traceValue": {
            "failedNodes": 0,
            "negated": true,
            "subResult": [],
            "successfulNodes": 1
          }
        }
      ]
    },
    {
      "@type": [
        "shacl:ValidationResult"
      ],
      "focusNode": {
        "@id": "file://./test/data/production/security/negative1.oas#/web-api"
      },
      "resultMessage": "Description\n\nThe security field of the operation has not been defined. This field specifies if your API operation requires the API consumer to authenticate to use it.\n\nFor more details, see the OpenAPI Specification.\nExample\n\nThe security field is tightly coupled with the securitySchemes objects. The security field could be missing because:\n\n    You forgot to define the securitySchemes field altogether, leaving the API completely unprotected.\n    You defined the securitySchemes field but not the security field. The definitions are not actually getting applied.\n    You defined the securitySchemes field and the operation-level security field for some of the API operations. However, you did not define the security field on the global level for the whole API.\n\nPossible exploit scenario\n\nIf you do not set the global security field, the API does not require any authentication by default. Anyone can use the API operations that do not have a security field defined. All they need to know is the URL for the API operation and how to invoke it.\n\nThis sometimes happens to internal APIs. These are often created only to be used inside the company web pages and mobile applications. No one expects any outsiders to know that the API exists, so developers do not spend time implementing security.\n\nBut attackers can look at the code of the mobile or web application, or listen to the API traffic, and reverse engineer how the API works. Once the attackers have figured this out, they can start using the API because it does not require any authentication.\n\nRelying on defining security only on each operation individually is an error-prone approach. It is very easy to forget to set security when you add a new method to the API. If there is no global default security defined, the operation is left wide open for an attacker to invoke without any authentication required.\n",
      "resultSeverity": {
        "@id": "http://www.w3.org/ns/shacl#Violation"
      },
      "sourceShapeName": "security-fields-operation-empty",
      "trace": [
        {
          "@type": [
            "validation:TraceMessage"
          ],
          "component": "maxCount",
          "resultPath": "security.security",
          "traceValue": {
            "actual": 0,
            "condition": "<=",
            "expected": 0,
            "negated": true
          }
        },
        {
          "@type": [
            "validation:TraceMessage"
          ],
          "component": "nested",
          "resultPath": "apiContract.endpoint / apiContract.supportedOperation",
          "traceValue": {
            "failedNodes": 1,
            "negated": false,
            "subResult": [
              {
                "@type": [
                  "shacl:ValidationResult"
                ],
                "focusNode": {
                  "@id": "file://./test/data/production/security/negative1.oas#/web-api/end-points/%2Fusers%2F%7Bid%7D/get"
                },
                "resultMessage": "error in nested nodes under apiContract.endpoint / apiContract.supportedOperation",
                "sourceShapeName": "nested",
                "trace": [
                  {
                    "@type": [
                      "validation:TraceMessage"
                    ],
                    "component": "minCount",
                    "resultPath": "security.security",
                    "traceValue": {
                      "actual": 0,
                      "condition": ">=",
                      "expected": 1,
                      "negated": false
                    }
                  }
                ]
              }
            ],
            "successfulNodes": 0
          }
        }
      ]
    }
  ]
}
