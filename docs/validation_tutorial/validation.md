# Validation Tutorial

This tutorial tells how to use the custom validation mechanism that enables you to 
define, group, document, reuse and execute common validation rules over a semantic graph. By making use of AMF parsing capabilities, you can define rules for RAML, OAS, and 
AsyncAPI specifications.

You can think of custom validations as a version of validation languages like XML Schema or JSON Schema but with the additional capability of
constraining the graph of metadata generated by AMF when parsing any of the supported specifications.

## 1. Writing and executing a custom validation

The custom validation mechanism requires that you define a set of validation rules known as **"Validation Profiles"**.

A validation profile defines the name of the profile, documentation, a set of rules and the severity
levels associated with each rule.

Profiles are encoded into YAML documents.
The next example shows a very simple validation profile:


File: *./examples/example1/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test1

violation:
  - version-format

validations:

  version-format:
    targetClass: apiContract.WebAPI
    propertyConstraints:
      core.version:
        pattern: ^v[0-9]+\.[0-9]+\.[0-9]+$
```

This profile defines a new profile, `Test1`, that has a single validation rule called `version-format`.
The validation constrains the version of the API model being parsed with a regular expression defining
the format of the version string.

The definition of the validation involves the following parts:

- `targetClass`: Defines a class of nodes in the parsed graph and that class is the target of the validation. This means that all 
nodes in the graph with that class, `apiContract.WebAPI` in this case, will be checked for all of the validation 
rules defined in the validation.

- `propertyConstraints`: Defines validation constraints for properties in the target node. In this case we are targeting
the `core.version` property and setting a `pattern` constraint.

Additionally the profile is setting a `violation` severity for this validation rule using the `violation` entry in the
document.

Let's try to validate an example API:

File: *./examples/example1/api.raml*
```yaml
#%RAML 1.0

title: Example API
version: 1.0
``` 

When can parse this RAML file with the AMF command: 

```bash
$ java -jar amf.jar parse ./docs/validation_tutorial/examples/example1/api.raml
```

AMF generates the following output JSON-LD graph:

```json
{
 "@graph": [
  {
   "@id": "amf://id#2",
   "@type": [
    "http://a.ml/vocabularies/apiContract#WebAPI",
    "http://a.ml/vocabularies/apiContract#API",
    "http://a.ml/vocabularies/document#RootDomainElement",
    "http://a.ml/vocabularies/document#DomainElement"
   ],
   "http://a.ml/vocabularies/core#name": "Example API",
   "http://a.ml/vocabularies/core#version": "1.0"
  },
  {
   "@id": "amf://id",
   "@type": [
    "http://a.ml/vocabularies/document#Document",
    "http://a.ml/vocabularies/document#Fragment",
    "http://a.ml/vocabularies/document#Module",
    "http://a.ml/vocabularies/document#Unit"
   ],
   "http://a.ml/vocabularies/document#encodes": {
    "@id": "amf://id#2"
   },
   "http://a.ml/vocabularies/document#root": true,
   "http://a.ml/vocabularies/document#processingData": {
    "@id": "amf://id#1"
   }
  },
  {
   "@id": "amf://id#1",
   "@type": [
    "http://a.ml/vocabularies/document#APIContractProcessingData"
   ],
   "http://a.ml/vocabularies/apiContract#modelVersion": "3.2.0",
   "http://a.ml/vocabularies/document#transformed": true,
   "http://a.ml/vocabularies/document#sourceSpec": "RAML 1.0"
  }
 ]
}
```

Here we can see how the node with id (`@id`) `amf://id#2` 
has associated the target class `apiContract:WebAPI`.
We can also see how the constrained property `core:version` is present and has the value `1.0`.

We can now invoke the custom validator passing the parsed JSON-LD graph and our custom profile, which will enforce our defined validation:

```bash
$ java -jar amf.jar parse ./docs/validation_tutorial/examples/example1/api.raml > api.jsonld
$ acv validate ./docs/validation_tutorial/examples/example1/profile.yaml api.jsonld
```

AMF Custom Validator will return a JSON-LD graph that contains the resulting validation. You will find a `ValidationReport` node, which contains information regarding the conformance, as well as a `ValidationResult` with information
about the 'version-format' validation that failed, its severity, and the targeted node.

```text
[
  {
    "@context": { .. },
    "@id": "dialect-instance",
    "@type": [
      "meta:DialectInstance",
      "doc:Document",
      "doc:Fragment",
      "doc:Module",
      "doc:Unit"
    ],
    "doc:encodes": [
      {
        "@id": "validation-report",
        "@type": [
          "reportSchema:ReportNode",
          "shacl:ValidationReport"
        ],
        "conforms": false,
        "profileName": "Test1",
        "result": [
          {
            "@id": "violation_0",
            "@type": [
              "reportSchema:ValidationResultNode",
              "shacl:ValidationResult"
            ],
            "focusNode": "amf://id#2",
            "resultMessage": "Validation error",
            "resultSeverity": "http://www.w3.org/ns/shacl#Violation",
            "sourceShapeName": "version-format",
            "trace": [
              {
                "@id": "violation_0_0",
                "@type": [
                  "reportSchema:TraceMessageNode",
                  "validation:TraceMessage"
                ],
                "component": "pattern",
                "resultPath": "http://a.ml/vocabularies/core#version",
                "traceValue": {
                  "@id": "violation_0_0_traceValue",
                  "@type": [
                    "reportSchema:TraceValueNode",
                    "validation:TraceValue"
                  ],
                  "argument": "1.0",
                  "negated": false
                }
              }
            ]
          }
        ]
      }
    ],
    "doc:processingData": [
      {
        "@id": "processing-data",
        "@type": [
          "doc:DialectInstanceProcessingData"
        ],
        "doc:sourceSpec": "Validation Report 1.0"
      }
    ]
  }
]
```

Great! We have validated our first API specification with a custom validation profile.

If we replace the version of the API specification by a compliant version according to the defined constraint, the validation error
should disappear from the report.

Notice that the same validation profile can also be applied to OAS or AsyncAPI specifications.
For example, if we write this equivalent OAS spec:

File: *./examples/example1/api.json*
```json
{
  "openapi": "3.0.0",
  "info": {
    "title": "Example API",
    "version": "1.0"
  },
  "paths": {}
}
```

If we parse and validate it:

```bash
$ java -jar amf.jar parse ./docs/validation_tutorial/examples/example1/api.json > api.jsonld
$ acv validate ./docs/validation_tutorial/examples/example1/profile.yaml api.jsonld
```


We should get an equivalent validation JSON-LD graph.

The rest of this tutorial expands on this basic flow, explaining how more sophisticated and advanced validation profiles
can be written.

## 2. Basic scalar validations

An easier way of writing validation rules is using simple property constraints through the `propertyConstraints` facet 
in the validation profile document.

There are a number of property constraints over scalar properties that can be defined:

- `pattern`: Validates the value of a property in a target node against the provided regular expression
- `maxCount`: Validates the maximum number of values that the target node can have for a property
- `minCount`: Validates the minimum number of values that the target node can have for a property
- `exactCount`: Validates the exact number of values that the target node can have for a property
- `maxLength`: Validates the maximum length of the string value that a property of the target node can have
- `minLength`: Validates the minimum length of the string value that a property of the target node can have
- `exactLength`: Validates the exact length of the string value that a property of the target node can have
- `minExclusive`: Validates the minimum value that a value in a property of the target node can have
- `maxExclusive`: Validates the maximum value that a value in a property of the target node can have
- `minInclusive`:Validates the minimum or equal value that a value in a property of the target node can have
- `maxInclusive`: Validates the maximum or equal value that a value in a property of the target node can have
- `datatype`: Validates the type of scalar value (integer, string, float, etc.) a value for a property of the target node must have
- `in`: Validates that the set of values for a property in a target node is a subset of the values provided as an array in the validation rule
- `containsAll`: Validates that the set of matched input values is equal or a superset of the values provided as arguments in the constraint
- `containsSome`: Validates that the intersection of the set of matched input values and the values provided as arguments in the constraint is not empty

All these validations must be associated to a particular property under the `propertyConstraints` property in a validation
profile rule. The key of the `propertyConstraints` node must be a namespaced version of the property URI.

You can find the name of the properties that can potentially be constrained in the JSON-LD output generated by the parser as a URI or CURIE. You can also find these properties in 
the standard description of the [API model](https://github.com/aml-org/amf/blob/develop/documentation/model.md) that is  
generated by AMF as a YAML file.

Let's unpack each of these validations.

### 2.1 Pattern

We already explained the way pattern works. It allows you to define a regular expression that will constrain any property
in any node holding a string value. If the property has multiple values, all of them will be validated.

For example, the following profile will constrain the possible values for the protocols associated with the API using a 
regular expression over the `apiContract.scheme` property of the `apiContract.WebAPI` node class:

File: *./examples/example2/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test2

violation:
  - allowed-protocols

validations:

  allowed-protocols:
    targetClass: apiContract.WebAPI
    propertyConstraints:
      apiContract.scheme:
        pattern: ^http|https$
```

Let's take a look at the following OAS 2.0 API spec that defines `ws` as valid for the protocols:

File: *./examples/example2/api.json*
```json
{
  "swagger": "2.0",
  "info": {
    "title": "Basic servers",
    "version": "1.0"
  },
  "schemes": [
    "https",
    "ws"
  ],
  "paths": {}
}
```

If we look at the JSON-LD graph generated by the parser, we can find two values, `http` and `ws`, for the `apiContract.schemes`
property:

```bash
java -jar amf.jar parse ./docs/validation_tutorial/examples/example2/api.json
```

```json
{
 "@graph": [
  {
   "@id": "amf://id#1",
   "@type": [
    "http://a.ml/vocabularies/document#APIContractProcessingData"
   ],
   "http://a.ml/vocabularies/apiContract#modelVersion": "3.2.0",
   "http://a.ml/vocabularies/document#transformed": true,
   "http://a.ml/vocabularies/document#sourceSpec": "OAS 2.0"
  },
  {
   "@id": "amf://id#2",
   "@type": [
    "http://a.ml/vocabularies/apiContract#WebAPI",
    "http://a.ml/vocabularies/apiContract#API",
    "http://a.ml/vocabularies/document#RootDomainElement",
    "http://a.ml/vocabularies/document#DomainElement"
   ],
   "http://a.ml/vocabularies/core#name": "Basic servers",
   "http://a.ml/vocabularies/apiContract#scheme": [
    "https",
    "ws"
   ],
   "http://a.ml/vocabularies/core#version": "1.0",
   "http://a.ml/vocabularies/apiContract#endpoint": []
  },
  {
   "@id": "amf://id",
   "@type": [
    "http://a.ml/vocabularies/document#Document",
    "http://a.ml/vocabularies/document#Fragment",
    "http://a.ml/vocabularies/document#Module",
    "http://a.ml/vocabularies/document#Unit"
   ],
   "http://a.ml/vocabularies/document#encodes": {
    "@id": "amf://id#2"
   },
   "http://a.ml/vocabularies/document#root": true,
   "http://a.ml/vocabularies/document#processingData": {
    "@id": "amf://id#1"
   }
  }
 ]
}
```

If we now try to validate using the profile we have just defined, we will obtain a validation constraint that points to the
`ws` protocol.

Notice how in this case the `pattern` validation constraint has been applied to both values of the `apiContract.scheme`
property.

**Escape character usage**: When using escape characters in your regular expression, make sure to avoid double quotes so that the special character conserves its raw value when parsed in yaml.

```pattern: ".*\?.*"``` will fail with a parse error when processing the yaml document.

```pattern: '.*\?.*'``` or ```pattern: .*\?.*``` will work as expected.

### 2.2 minCount, maxCount and exactCount

Validation constraints `minCount`, `maxCount`, and `exactCount` can be used to limit how many values a property in any target node can have.

`minCount` is especially interesting since it can be used to make part of the spec optional, if set with a `minCount` value
of zero or mandatory if `minCount` has a value major than zero.

For example, the following profile makes it mandatory to provide the name of an operation, parsed as a node of class 
`apiContract.Operation` through the `core.name` property:

File: *./examples/example3/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test3a

violation:
  - mandatory-operation-name

validations:

  mandatory-operation-name:
    targetClass: apiContract.Operation
    propertyConstraints:
      core.name:
        minCount: 1
```

In OAS 3.0, names for operations are provided through the `operationId` property, so the following API should trigger a
validation error:

```yaml
openapi: 3.0.0

info:
  title: Example API

paths:
  /test:
    get:
      summary: test path
```

If we provide the `operationId` value for the `get` operation in the `/test` endpoint, the validation will disappear.

`maxCount` can be used to limit the maximum number of values a property can have in the parsed graph.

For example we could modify the profile discussed in section 2.1 to limit not only the value of the protocol schemes but
also the number of protocols that can defined on a single Web API:

File: *./examples/example3/profile2.yaml*
```yaml
#%Validation Profile 1.0

profile: Test2 Modified

violation:
  - allowed-protocols

validations:

  allowed-protocols:
    targetClass: apiContract.WebAPI
    propertyConstraints:
      apiContract.scheme:
        pattern: ^http|https$
        maxCount: 1
```

After these changes, validating the previous OAS 2.0 spec defined in section 2.1 should produce two errors, one about the value of the
schemes and another one about the maximum number of schemes defined.

### 2.3 minLength, maxLength and exactLength

This set of constraints makes it possible to control the length of string values in the parsed graph.

For example, the following profile uses these constraints to limit the length of the string the user can provide for a description:

```yaml
#%Validation Profile 1.0

profile: string length example

violation:
 - description-length-validation

validations:

 description-length-validation:
  targetClass: apiContract.WebAPI
  propertyConstraints:
   apiContract.description:
    minLength: 40
    maxLength: 100
 ```

If we validate the following API, we should obtain a validation error due to the length of the string provided in the description of our API.

```yaml
#%RAML 1.0

title: Example API
version: 1.0
description: short description
```

### 2.4 minExclusive, maxExclusive, minInclusive, maxInclusive

This set of constraints makes it possible to control the ranges of numeric values in the parsed graph.

For example, the following profile uses these constraints to limit the range of values that are valid for the elements
defined for a RAML Array type:
 
 File: *./examples/example4/profile.yaml*
 ```yaml
#%Validation Profile 1.0

profile: Test4

violation:
  - array-limits

validations:

  array-limits:
    targetClass: raml-shapes.ArrayShape
    propertyConstraints:
      shacl.minCount:
        minInclusive: 25
        maxExclusive: 50
 ```

In this `array-limits` validation rule, we want to target all RAML arrays, parsed as `raml-shapes.ArrayShape` nodes. We have set up
two constraints, `minInclusive` and `maxExclusive`, to constrain the possible values for the elements in the array, parsed
by AMF as `shacl.minCount` properties in the output graph.
The values are constrained betweeen the values 25 (inclusive) and 50.

Provided a simple API defining some array types:

```yaml
#%RAML 1.0

title: Example API
version: 1.0

types:
  Emails:
    type: any[]
    minItems: 100
```

If we try to parse it using the previous validation profile, we should obtain a validation error, since the `minItems` value for
the defined array (100) does not fall between the [25,50) range.

### 2.5 datatype

`datatype` is a constraint that limits the valid scalar value for a property in the parsed graph. This constraint is not
particularly useful in custom validations, since RAML, OAS and AsyncAPI have well defined types for all the properties. However, 
it can still used to modify standard type definitions, such as making it mandatory for a version to be an integer
instead of a string.

### 2.6 in

`in` makes it possible to specify an enumeration of values that constrain the possible values for a certain property in
a node. Values can be booleans, numeric values, or strings.

The following example rewrites the profile used as an example in section 2.1. It uses an `in` constraint instead of `pattern`
to constrain the possible values for the default `schemes` in an API spec:

```yaml
#%Validation Profile 1.0

profile: Test5

violation:
  - allowed-protocols

validations:

  allowed-protocols:
    targetClass: apiContract.WebAPI
    propertyConstraints:
      apiContract.scheme:
        in: [ http, https ]
``` 

If we try to validate the OAS 2 API defined in section 2.1 with this profile we will obtain an equivalent violation.

### 2.7 containsAll

`in` makes sure that the set of matching values in the input data is a subset or equal to the set of values provided
in the constraint.
Sometimes we want to require that the matching values must be a superset or equal to a different set of values.
`containsAll` can be used in these situations to indicate the values that must be extended by the values in the input data.

In the following example, we require that the operations for any `apiContract:EndPoint` in an API must include at least the GET and POST
operations using `containsAll`.

```yaml
#%Validation Profile 1.0

profile: Test5

violation:
  - mandatory-operations

validations:

 mandatory-operations:
    targetClass: apiContract.EndPoint
    propertyConstraints:
      apiContract.supportedOperation / apiContract.method:
        containsAll: [ get, post ]
``` 


### 2.8 containsSome

`containsSome` is an alternative to `containsAll` where instead of checking that the input selected values are equal or 
a superset of the provided values, we are checking that the interesection between the values is not empty.

In other words we are checking that at least one of the provided values is in the set of matching input
values.

The previous example could be rewritten using `containsSome` and in this case, instead of checking that both of the operations GET and
POST are included, we would be checking that either the GET or the POST operation are defined for each `apiContract:EndPoint`.

```yaml
#%Validation Profile 1.0

profile: Test5

violation:
  - mandatory-operations

validations:

  mandatory-operations:
    targetClass: apiContract.EndPoint
    propertyConstraints:
      apiContract.supportedOperation / apiContract.method:
        containsSome: [ http, https ]
``` 


## 3. Property pairs validations

Validation constraints discussed in section 2 are all validations over a single scalar property. In this section we will
review validations constraining pairs of scalar properties:

- *lessThanProperty*: Establishes a less than constraint over the values of two scalar properties in a node
- *lessThanOrEqualsToProperty*: Establishes a more than constraint over the values of two scalar properties in a noe
- *equalsToProperty*: Establishes an equality constraint over tha values of two scalar properties in a node
- *disjointWithProperty*: Establishes an inequality constraint over the values of two scalar properties in a node

The rest of this section will review and provide examples of these constraints.

### 3.1 lessThanProperty, lessThanOrEqualsToProperty

`lessThanProperty` and `lessThanOrEqualsToProperty` make it possible to define that the values in one property of a node
must be less than or less than or equal to the values in another property of the same node.

The following OAS 3.0.0 API spec defines maximum and minimum length for a string schema called `name`:

File: *./examples/example6/api.yaml*
```yaml
openapi: 3.0.0

info:
  title: Example API

components:
  schemas:
    name:
      type: string
      minLength: 500
      maxLength: 100

paths: {}
```

Here we can see how there is an error over those limits, making `minLength` greater than the `maxLength`.

If we parse the specification, we can see how both JSON Schema constraints are stored in the parsed graph using the 
`sh:minLength` and `sh:maxLength` properties of a `shapes:ScalarShape` node:

```bash
java -jar amf.jar parse ./docs/validation_tutorial/examples/example6/api.yaml
```

```json
{
 "@graph": [
  {
   "@id": "amf://id#1",
   "@type": [
    "http://a.ml/vocabularies/shapes#ScalarShape",
    "http://a.ml/vocabularies/shapes#AnyShape",
    "http://www.w3.org/ns/shacl#Shape",
    "http://a.ml/vocabularies/shapes#Shape",
    "http://a.ml/vocabularies/document#DomainElement"
   ],
   "http://www.w3.org/ns/shacl#datatype": [
    {
     "@id": "http://www.w3.org/2001/XMLSchema#string"
    }
   ],
   "http://www.w3.org/ns/shacl#minLength": 500,
   "http://www.w3.org/ns/shacl#maxLength": 100,
   "http://www.w3.org/ns/shacl#name": "name"
  },
  ...
 ]
}
```

We could write a validation profile to capture these kind of errors:

```yaml
#%Validation Profile 1.0

profile: Test6

violation:
  - test-min-length

validations:
  test-min-length:
    targetClass: shapes.ScalarShape
    message: Min length must be less than max length
    propertyConstraints:
      shacl.minLength:
       lessThanProperty: shacl.maxLength
```

Notice how the value for the `lessThanProperty` is another property that is the target of the comparison, in this case `shacl.maxLength`.


### 3.2 equalsToProperty, disjointWithProperty

`equalsToProperty` and `disjointWithProperty` makes it possible to state that the values in two properties of the same
node must have the same or different values.

The following profile will define two validation rules, one stating that `minLength` and `maxLength` for a string, as shown
in example 3.1, must be equal or different:

File: *./examples/example7/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test7

violation:
  - test-equals
  - test-different

validations:
  test-equals:
    targetClass: raml-shapes.ScalarShape
    message: Min and max length must match in scalar
    propertyConstraints:
      shacl.maxLength:
        equalsToProperty: shacl.minLength

  test-different:
    targetClass: raml-shapes.ScalarShape
    message: Min and max length must not match in scalar
    propertyConstraints:
      shacl.maxLength:
        disjointWithProperty: shacl.minLength
```

If we try to validate the example API spec in section 3.1 with this new profile, the validation about values being the
same will fail.

If we modify the spec to provide the same value and we re-validate, two new errors will now be shown for the complementary
validation about values being disjointed.

```yaml
openapi: 3.0.0

info:
  title: Example API

components:
  schemas:
    name:
      type: string
      minLength: 100
      maxLength: 100

paths: {}
```

## 4. Nested node validations and property paths

So far we have discussed examples where constraints were set for properties for a single node.

The custom validation mechanism also supports defining validations for multiple nodes in the same validation rules,
connecting them with nesting constraints:

- *nested*: Constrains all nested nodes connected to the target node through some property

As an alternative, the properties for constraints can be defined as property paths that make it possible to express
nesting traversing the output graph in a simple and efficient way.

The following sections review each of these constraints.

### 4.1 nested

`nested` can be used to add additional constraints to nodes nested under the target node and connected through a
specific property.

Consider the following simple RAML API:

File: *./examples/example8/api.raml*
```yaml
#%RAML 1.0

title: Test API

/endpoint1:
  get:
    queryParameters:
      a:
    body:
      application/json:
        properties:
          b:
```

In this API spec, two scalar RAML types are defined, `a` and `b`. `a` is defined as the schema for a `queryParameter` while
`b` is defined as the schema for a property in the request payload.

The `nested` constraint can be used to define validations for scalar RAML types that are used as schemas for parameters. 
In the parsed graph, `apiContract:Parameter` nodes are connected to the `raml-shapes:ScalarShape` used in parameters through
the `raml-shapes:schema` property, so that is the property we need to connect the nested validation.

File: *./examples/example8/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test8

violation:
  - scalar-parameters

validations:
  scalar-parameters:
    targetClass: apiContract.Parameter
    message: Scalars in parameters must have minLength defined
    propertyConstraints:
      raml-shapes.schema:
        minCount: 1
        nested:
          propertyConstraints:
            shacl.minLength:
              minCount: 1
```

With this profile, if we try to validate the API, we will obtain a validation violation for the scalar of parameter `a`
while the scalar `b` validates correctly.

Nested can be applied multiple times in a validation rule definition. For example the previous rule could be rewritten
targeting the `apiContract:Request` node that is the parent of the `apiContract:Parameter` node:

File: *./examples/example8/profile2.yaml*
```yaml
#%Validation Profile 1.0

profile: Test8

violation:
  - scalar-parameters

validations:
  scalar-parameters:
    targetClass: apiContract.Request
    message: Scalars in parameters must have minLength defined
    propertyConstraints:
      apiContract.parameter:
        minCount: 1
        nested:
          propertyConstraints:
            raml-shapes.schema:
              minCount: 1
              nested:
                propertyConstraints:
                  shacl.minLength:
                    minCount: 1
```

### 4.2 Property paths

At the end of section 4.1 we saw how multiple nested clauses can be used to describe a path of validations through
the parsed output graph.

This way can be useful if we want to define additional constraints at different nodes that are being traversed, but as a
mechanism to reach a target nested node, this way is too verbose and error prone.

Property paths are a simple way to traverse and reach the target node of the graph that is being validated.

Property paths are built using a simple subset of SPARQL property path syntax:

- *Predicates*: Any property identifier, like `core.name` or `apiContract.expects` are valid property paths
- *Sequence paths*: Sequences in the form `a / b / c / ...` where `a`, `a` and `c` are valid property paths
- *Alternate paths*: Alternative paths in the form `a | b | c | ...` where `a`, `a` and `c` are valid property paths
- *Inverse paths*: Expressed as `a^` where `a` is a valid predicate like `core.name` or `apiContract.expects`

All these types of paths can be combined in complex expressions reaching any part of the output graph from a target node.
Notice that `sequence paths` have a greater priority than `alternate paths` in path expressions. Parenthesis can be used
to change the associativity in a path expression.

Let's review each of these types of path expressions. 

#### 4.2.1 Sequence paths

Sequence paths are a concatenation of properties from one node to a set of target nodes.

The last example of section 4.1 could be rewritten to simply use a path `apiContract.parameter / raml-shapes.schema` 
instead of two nested clauses:

File: *./examples/example9/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test9

violation:
  - scalar-parameters

validations:

  scalar-parameters:
    targetClass: apiContract.Request
    message: Scalars in parameters must have minLength defined
    propertyConstraints:
      apiContract.parameter / raml-shapes.schema:
        nested:
          shacl.minLength:
            minCount: 1
```

#### 4.2.2 Alternate paths

Alternate paths make it possible to reach target nodes in different parts of the output graph that must be validated in
the same way.

For example, in the API spec used as example in section 4.1, scalar RAML types are used in parameters and also as
properties in the payload. If we want to constrain both types of scalar types, and only the ones at those positions, 
with the same constraint for `minLength`, we could use an `alterante path` to apply it in both cases:

File: *./examples/example9/profile2.yaml*
```yaml
#%Validation Profile 1.0

profile: Test9b

violation:
  - scalar-parameters

validations:

  scalar-parameters:
    targetClass: apiContract.Operation
    message: Scalars in parameters must have minLength defined
    propertyConstraints:
      apiContract.expects / (apiContract.parameter / raml-shapes.schema | apiContract.payload / raml-shapes.schema / shacl.property / raml-shapes.range) :
        nested:
          propertyConstraints:
            shacl.minLength:
              minCount: 1
```

In this profile we first select scalar type nodes in the parameters and request body using the path 
expression `apiContract.expects / (apiContract.parameter / raml-shapes.schema | apiContract.payload / raml-shapes.schema / shacl.property / raml-shapes.range)`.

Once the target nodes have been selected we validate the `shacl.minLength` property in the node through the `nested` constraint.

If we try to parse the example in section 4.1 with this profile we will obtain two validation errors, one for the parameter and 
another one for the body.

#### 4.2.3 Inverse paths

Inverse paths traverse the graph in the opposite direction from target node to parent node instead of from target node
to nested node.

### 4.3 Custom properties

Different API specifications provide mechanisms to extend the kind of information that can be expressed in the specification.
Annotations in RAML, vendor extensions in OAS, directives in GraphQL and custom options in gRPC protobuffers are examples
of these extensions mechanisms.

Consider the following examples:

```raml
#%RAML 1.0
title: example api
version: 1.0.0

annotationTypes:
  ext:
    type: string

(wadus): "value"
```

```yaml
openapi: "3.0.0"
info:
  title: example API
  version: "1.0.0"
paths: {}
x-wadus: "value"
```

```graphql
directive @wadus(message: String) on SCHEMA

schema @wadus(message: "value") {
  query: Query
}

type Query {
  field: String
}
```

```protobuf
syntax = "proto3";

package example;


import "options.proto";

option (wadus) = "value";

service GRPCMinimal {
  rpc one_to_one (Request) returns (Reply) {}
  rpc one_to_many (Request) returns (stream Reply) {}
  rpc many_to_one (stream Request) returns (Reply) {}
  rpc many_to_many (stream Request) returns (stream Reply) {}
}

message Request {
  string message = 1;
}

message Reply {
  string message = 1;
}
```

with `options.proto` being:

```protobuf
syntax = "proto2";

package example;

import "google/protobuf/descriptor.proto";

extend google.protobuf.FileOptions {
    optional string wadus = 50000;
}
```

All these examples define (if possible) and apply a custom property called `wadus` that extend the kind of information
that can be defined at the top-level object of the API.

Note that the syntax for the actual extension can be different, for example in OAS, the prefix `x-` must be used while in 
GraphQL the extensions require using a directive prefixed by `@` and parameter name for the value.

When AMF parses all these specs it generates the same element in the JSON-LD model. a `data:Object` connected by custom
`doc:DomainProperty` with a name matching the name of the extension.

In order to refer to the values connected via custom properties in the API model, we can use a special prefix `apiExt`
to mix standard and custom properties in the `propertyConstraints` paths of a rule.

For example if we would like to specify a rule that checks that the `wadus` custom property is applied at the top-level
element of the API model we could write the following profile:

```yaml
#%Validation Profile 1.0

profile: extensions-example
violation:
  - wadus-is-mandatory
validations:
 wadus-is-mandatory:
    message: wadus is a mandatory extension
    targetClass: apiContract.WebAPI
    propertyConstraints:
      apiExt.wadus:
        minCount: 1
```

As we can see here, the property `apiExt.wadus` instructs the validator to look for custom domain property with name
`wadus` from the target node, in this case the `apiContract.WebAPI.

Custom domain properties, specified via the prefix `apiExt` can be mixed with regular properties in any property path,
including inverse navigation statements.

## 5. Qualified constraints

Qualified constraints make it possible to express validation rules that match only a minimum or maximum number of the target
nodes selected by a particular constraint.


These are the qualified constraints supported:

- *atLeast*: Makes it possible to check that a particular validation rule matches a minimum number of the target nodes
- *atMost*: Makes it possible to check that a particular validation rule matches a maximum number of the target nodes

The following API describes a RAML API with different endpoints supporting each different set of HTTP operations:

File: *./examples/example10/api.raml*
```yaml
#%RAML 1.0

title: Test API

/endpoint1:
  get:

/endpoint2:
  get:
  post:
```

This API generates the following JSON-LD graph when parsed by AMF:

```bash
java -jar amf.jar parse ./docs/validation_tutorial/examples/example10/api.raml
```

```json
{
 "@graph": [
  {
   "@id": "amf://id#2",
   "@type": [
    "http://a.ml/vocabularies/apiContract#WebAPI",
    "http://a.ml/vocabularies/apiContract#API",
    "http://a.ml/vocabularies/document#RootDomainElement",
    "http://a.ml/vocabularies/document#DomainElement"
   ],
   "http://a.ml/vocabularies/core#name": "Test API",
   "http://a.ml/vocabularies/apiContract#endpoint": [
    {
     "@id": "amf://id#3"
    },
    {
     "@id": "amf://id#5"
    }
   ]
  },
  {
   "@id": "amf://id#3",
   "@type": [
    "http://a.ml/vocabularies/apiContract#EndPoint",
    "http://a.ml/vocabularies/document#DomainElement"
   ],
   "http://a.ml/vocabularies/apiContract#path": "/endpoint1",
   "http://a.ml/vocabularies/apiContract#supportedOperation": [
    {
     "@id": "amf://id#4"
    }
   ]
  },
  {
   "@id": "amf://id#5",
   "@type": [
    "http://a.ml/vocabularies/apiContract#EndPoint",
    "http://a.ml/vocabularies/document#DomainElement"
   ],
   "http://a.ml/vocabularies/apiContract#path": "/endpoint2",
   "http://a.ml/vocabularies/apiContract#supportedOperation": [
    {
     "@id": "amf://id#6"
    },
    {
     "@id": "amf://id#7"
    }
   ]
  },
  {
   "@id": "amf://id#4",
   "@type": [
    "http://a.ml/vocabularies/apiContract#Operation",
    "http://a.ml/vocabularies/document#DomainElement"
   ],
   "http://a.ml/vocabularies/apiContract#method": "get"
  },
  {
   "@id": "amf://id#6",
   "@type": [
    "http://a.ml/vocabularies/apiContract#Operation",
    "http://a.ml/vocabularies/document#DomainElement"
   ],
   "http://a.ml/vocabularies/apiContract#method": "get"
  },
  {
   "@id": "amf://id#7",
   "@type": [
    "http://a.ml/vocabularies/apiContract#Operation",
    "http://a.ml/vocabularies/document#DomainElement"
   ],
   "http://a.ml/vocabularies/apiContract#method": "post"
  },
  ...
 ]
}
```

Notice how each parsed `apiContract:EndPoint` has an associated `apiContrat.Operation`, each with a number of defined 
`apiContract:method` (`get` or `post`).

We could define a profile to check that each endpoint has *at least* one POST operation:

File: *./examples/example10/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test10

violation:
  - at-least-one-post

validations:

  at-least-one-post:
    message: Endpoints must have a POST method
    targetClass: apiContract.EndPoint
    propertyConstraints:
      apiContract.supportedOperation:
        atLeast:
          count: 1
          validation:
            propertyConstraints:
              apiContract.method:
                in: [ post ]
```

If we try to validate the API against this profile, we will get an error about the endpoints without the post operation.

In the same way as the preceding example, we could generate a profile validating that an API is read-only by validating that no endpoint has a 
put, patch, post or delete methods using a `atMost` qualified constraint with value `0`:

File: *./examples/example10/profile2.yaml*
```yaml
#%Validation Profile 1.0

profile: Test10b

violation:
  - read-only-endpoints

validations:

  read-only-endpoints:
    message: Endpoints must be read-only
    targetClass: apiContract.EndPoint
    propertyConstraints:
      apiContract.supportedOperation:
        atMost:
          count: 0
          validation:
            propertyConstraints:
              apiContract.method:
                in: [ post, put, patch, delete ]
```

Trying to parse with this new profile will result in a validation error for the endpoint with a `post` method.

## 6. Logical constraints

Logical constraints make it possible to combine set of constraints using basic boolean logic operators like: `and`, `or` and
`not`.

- *and*: Combines a set of validation rules using a logical and
- *or*: Combines a set of validation rules using a logical or
- *not*: Negates a validation rule

Logical constraints are introduced at the top level definition of a validation rule and can be combined and nested to achieve
complex validation logic.

In the following sections we will review each of these constraints with some examples.

### 6.1 and

`And` combines multiple rules using a logical and to compute the final validation result.

The following RAML API shows a simple RAML API where a GET operation defines multiple status codes for the operation
responses: 

File: *./examples/example11/api.raml*
```yaml
#%RAML 1.0

title: Test API

/endpoint:
  get:
    responses:
      200:
      201:
      300:
      400:
      401:
```

The AMF model uses a single operation with multiple response nodes for each status code that is defined.

We could write a simple validation profile to check that every get operation has documentation defined for status codes 
 in the ranges 2XX, 4XX and 5XX.
 
 File: *./examples/example11/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test11

violation:
  - and-rule

validations:

  and-rule:
    message: Operations must have 2xx, 4xx and 5xx status codes
    targetClass: apiContract.Operation
    and:
      - propertyConstraints:
          apiContract.returns:
            atLeast:
              count: 1
              validation:
               propertyConstraints:
                  apiContract.statusCode:
                    pattern: ^2[0-9]{2}$
      - propertyConstraints:
          apiContract.returns:
            atLeast:
              count: 1
              validation:
                propertyConstraints:
                  apiContract.statusCode:
                    pattern: ^4[0-9]{2}$
      - propertyConstraints:
          apiContract.returns:
            atLeast:
              count: 1
              validation:
                propertyConstraints:
                  apiContract.statusCode:
                    pattern: ^5[0-9]{2}$
```

If we validate the API spec with this profile, an error will be reported for the missing error in the 5XX range.

### 6.2 or

In section 6.1 we have defined a validation profile with a rule to validate that all operations have status codes defined
in the ranges 2XX, 3XX and 5XX.

However sometimes we would like to express conditions for certain target nodes to validate. `or` logical constraints can
be used to achieve this behaviour. For example, let's refine our rule to validate status codes in the ranges 2XX, 3XX
and 5XX only for GET operations.

We can achieve this expressing in the validation rule that the operation must validate the status code condition or be
a PUT, POST, DELETE or PATCH operation:

File: *./examples/example12/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test12

violation:
  - and-or-rule

validations:

  and-or-rule:
    message: GET operations must have 2xx, 4xx and 5xx status codes
    targetClass: apiContract.Operation
    or:
      - propertyConstraints:
          apiContract.method:
            in: [ post, put, patch, delete ]
      - and:
        - propertyConstraints:
            apiContract.returns:
              atLeast:
                count: 1
                validation:
                  propertyConstraints:
                    apiContract.statusCode:
                      pattern: ^2[0-9]{2}$
        - propertyConstraints:
            apiContract.returns:
              atLeast:
                count: 1
                validation:
                  propertyConstraints:
                    apiContract.statusCode:
                      pattern: ^4[0-9]{2}$
        - propertyConstraints:
            apiContract.returns:
              atLeast:
                count: 1
                validation:
                  propertyConstraints:
                    apiContract.statusCode:
                      pattern: ^5[0-9]{2}$
```

If we use this profile the API discussed in section 6.1 will still fail.

However, if we define a new API spec with the same operation and list of status codes but for a `post` method, it will validate correctly:

File: *./examples/example12/api.raml*
```yaml
#%RAML 1.0

title: Test API

/endpoint1:
  post:
    responses:
      200:
      201:
      300:
      400:
      401:
```

### 6.3 not

`not`makes it possible to negate a validation rule and combine it logically with other rules.

For example, let's continue refining the example discussed in section 6.2. We can use `not` to simplify the constraint
about the method being either `put`, `post`, `delete` or `patch` by simply asserting that the method must not be `get`.

Additionally we can add another rule to the top-level conjunction to avoid `get` operations returning `201` (created) status
codes:

File: *./examples/example13/profile.yaml*
```yaml
#%Validation Profile 1.0

profile: Test13

violation:
  - and-or-not-rule

validations:

  and-or-not-rule:
    message: GET operations must have 2xx, 4xx and 5xx status codes but no 201
    targetClass: apiContract.Operation
    or:
      - not:
          propertyConstraints:
            apiContract.method:
              in: [ get ]
      - and:
          - not:
              propertyConstraints:
                apiContract.returns:
                  atLeast:
                    count: 1
                    validation:
                      propertyConstraints:
                        apiContract.statusCode:
                          pattern: "^201$"
          - propertyConstraints:
              apiContract.returns:
                atLeast:
                  count: 1
                  validation:
                    propertyConstraints:
                      apiContract.statusCode:
                        pattern: ^2[0-9]{2}$
          - propertyConstraints:
              apiContract.returns:
                atLeast:
                  count: 1
                  validation:
                    propertyConstraints:
                      apiContract.statusCode:
                        pattern: ^4[0-9]{2}$
          - propertyConstraints:
              apiContract.returns:
                atLeast:
                  count: 1
                  validation:
                    propertyConstraints:
                      apiContract.statusCode:
                        pattern: ^5[0-9]{2}$
```

### 6.5 conditionals

Sometimes constraints must be expressed as conditional statements. For example, in the following profile we are verifying that
if a field is named `created_at`, it has a schema of type `dateTime`:

```yaml
#%Validation Profile 1.0

profile: Test13b

violation:
 - common-field-types-modified-at

validations:
  common-field-types-modified-at:
    message: Modified-at fields must be date-times
    targetClass: shapes.Shape
    or:
      - not:
          propertyConstraints:
            shacl.name:
              in:
                - modified_at
      - propertyConstraints:
          shacl.datatype:
            in:
              - xsd:dateTime
```
In the example we are using [material implication](https://en.wikipedia.org/wiki/Material_implication_(rule_of_inference)) to express the condition
using an `or` constraint.

The same constraint can be rewritten to use the `if` / `then` conditional constraint directly:

```yaml
#%Validation Profile 1.0

profile: Test13b

violation:
 - common-field-types-modified-at

validations:
  common-field-types-modified-at:
    message: Modified-at fields must be date-times
    targetClass: shapes.Shape
    if:
      propertyConstraints:
        shacl.name:
          in:
            - modified_at
    then:
      propertyConstraints:
        shacl.datatype:
          in:
            - xsd:dateTime
```

Optionally, the `else` clause can also be used to define a constraint for the case where the `if` condition does not match.

## 7. Rego rules

Validation can be written directly using the [Rego policy language](https://www.openpolicyagent.org/docs/latest/policy-language/) provided by the [Open Policy Agent](https://www.openpolicyagent.org/) initiative.

Rego rules are defined as a template that works over a provided node in the input JSON-LD document, performs some kind of validation, and returns a result.
The input node is passed to the Rego template code through the `$node` variable and the positive result of the check must be stored 
in the `$result` variable.

The code must contain a validation that holds true for all nodes in the spec being selected by the validation containing the Rego rule.

The following profile writes a simple rule to check whether the version of the apiContract.WebAPI spec is defined:

```yaml
#%Validation Profile 1.0

profile: Test16

violation:
  - operation-tag-defined

validations:

  operation-tag-defined:
    message: Operation tags should be defined in global tags.
    targetClass: apiContract.WebAPI
    rego: |
      o1 = collect with data.nodes as [$node] with data.property as "apiContract:tag"
      top_level_tags = collect_values with data.nodes as o1 with data.property as "core:name"

      p1 = collect with data.nodes as [$node] with data.property as "apiContract:endpoint"
      p2 = collect with data.nodes as p1 with data.property as  "apiContract:supportedOperation"
      p3 = collect with data.nodes as p2 with data.property as "apiContract:tag"
      operation_tags = collect_values with data.nodes as p3 with data.property as "core:name"

      common_tags = operation_tags & top_level_tags
      $result = (count(common_tags) == count(operation_tags))
```

In the preceding example, the `targetClass: apiContract.WebAPI` validation target selects the top level API node, which is 
referenced as `$node` in the Repo snippet. The snippet verifies that the provided `$node` (top level API node) declares all 
the tags that are being used in each operation.

The final result is being stored in the `$result` variable. 

To write the Rego rule, a set of auxiliary Rego rules to navigate the JSON-LD graph can be used, such as the `collect` and `collect_values` rules used in the example.

Rego constraints can be used anywhere a regular constraint can be used. They can be nested in other complex constraints.